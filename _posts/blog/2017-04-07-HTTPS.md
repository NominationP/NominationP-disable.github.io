---
layout: article
title: "HTTPS"
modified:
category: blog
tag:
- Https
- Web

#excerpt:
toc: true
image:
#  feature:
    teaser: /blog/2017.04.07/cover.jpg
#  thumb:
date:   2017-04-07 10:05
modified: 2017-04-09 15:05
---


> 互联网的通信安全，建立在SSL/TLS协议之上

##  [HTTP 协议入门](http://www.ruanyifeng.com/blog/2016/08/http.html){:target="_blank"}

### key words

>  HTTP/1.0  请求格式 回应格式 Content-Type 字段 Content-Encoding 字段 缺点
    HTTP/1.1 持久连接 管道机制 Content-Length 字段 分块传输编码 Host字段 虚拟主机 "队头堵塞"（Head-of-line blocking）
    HTTP/2 二进制协议 多工 数据流 头信息压缩 服务器推送



##  [SSL/TLS协议运行机制的概述](http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html){:target="_blank"}

### 作用

|风险|http|https|
|---|---|---|
|窃听风险（eavesdropping）|第三方可以获知通信内容|所有信息都是加密传播，第三方无法窃听|
|篡改风险（tampering）|第三方可以修改通信内容|具有校验机制，一旦被篡改，通信双方会立刻发现|
|冒充风险（pretending）|第三方可以冒充他人身份参与通信|配备身份证书，防止身份被冒充|

### 历史
互联网加密通信协议的历史，几乎与互联网一样长。

>1994年，NetScape公司设计了SSL协议（Secure Sockets Layer）的1.0版，但是未发布。
1995年，NetScape公司发布SSL 2.0版，很快发现有严重漏洞。
1996年，SSL 3.0版问世，得到大规模应用。
1999年，互联网标准化组织ISOC接替NetScape公司，发布了SSL的升级版TLS 1.0版。
2006年和2008年，TLS进行了两次升级，分别为TLS 1.1版和TLS 1.2版。最新的变动是2011年TLS 1.2的修订版。

### 基本的运行过程
SSL/TLS协议的基本思路是采用公钥加密法，也就是说，客户端先向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密。

1. 如何保证公钥不被篡改？
> 解决方法：将公钥放在数字证书中。只要证书是可信的，公钥就是可信的。

2. 公钥加密计算量太大，如何减少耗用的时间？
> 解决方法：每一次对话（session），客户端和服务器端都生成一个"对话密钥"（session key），用它来加密信息。由于"对话密钥"是对称加密，所以运算速度非常快，而服务器公钥只用于加密"对话密钥"本身，这样就减少了加密运算的消耗时间。

因此，SSL/TLS协议的基本过程是这样的：

>（1） 客户端向服务器端索要并验证公钥。
（2） 双方协商生成"对话密钥"。
（3） 双方采用"对话密钥"进行加密通信。

上面过程的前两步，又称为"握手阶段"（handshake）。

### 握手阶段的详细过程


![Alt text](/images/blog/2017.04.07/handshake.png)

"握手阶段"涉及四次通信，我们一个个来看。需要注意的是，"握手阶段"的所有通信都是明文的。

1. 客户端发出请求（ClientHello）

>（1） 支持的协议版本，比如TLS 1.0版。
（2） 一个客户端生成的随机数，稍后用于生成"对话密钥"。
（3） 支持的加密方法，比如RSA公钥加密。
（4） 支持的压缩方法。

2. 服务器回应（SeverHello）

>（1） 确认使用的加密通信协议版本，比如TLS 1.0版本。如果浏览器与服务器支持的版本不一致，服务器关闭加密通信。
（2） 一个服务器生成的随机数，稍后用于生成"对话密钥"。
（3） 确认使用的加密方法，比如RSA公钥加密。
（4） 服务器证书。

3. 客户端回应

> （1） 一个随机数。该随机数用服务器公钥加密，防止被窃听。
（2） 编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。
（3） 客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供服务器校验。

> 上面第一项的随机数，是整个握手阶段出现的第三个随机数，又称"pre-master key"。有了它以后，客户端和服务器就同时有了三个随机数，接着双方就用事先商定的加密方法，各自生成本次会话所用的同一把"会话密钥"。


----------


>**`补充内容`** [大型网站的HTTPS实践一：HTTPS协议和原理](http://www.admin5.com/article/20150505/597061.shtml){:target="_blank"}
>
> 浏览器接收到 random2 之后就能够生成 premaster_secrect 以及 master_secrect。其中 premaster_secret 长度为 48 个字节，前 2 个字节是协议版本号，剩下的 46 个字节填充一个随机数。

>   master secrect 的生成算法简述如下：
    Master_key = PRF(premaster_secret, “master secrect”, 随机数1+随机数2)其中 PRF 是一个随机函数，定义如下：PRF(secret, label, seed) = P_MD5(S1, label + seed) XOR P_SHA-1(S2, label + seed)
>
>   从上式可以看出，把 premaster_key 赋值给 secret，”master key”赋值给 label，浏览器和服务器端的两个随机数做种子就能确定地求出一个 48 位长的随机数。
>
> 而 master secrect 包含了六部分内容，分别是用于校验内容一致性的密钥，用于对称内容加解密的密钥，以及初始化向量(用于 CBC 模式)，客户端和服务端各一份。

4. 服务器的最后回应

>（1）编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。
（2）服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供客户端校验。

##  [图解SSL/TLS协议](http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html){:target="_blank"}

### SSL协议的握手过程

![Alt text](/images/blog/2017.04.07/handshake_ex.png)

> 第一步，爱丽丝给出协议版本号、一个客户端生成的随机数（Client random），以及客户端支持的加密方法。
第二步，鲍勃确认双方使用的加密方法，并给出数字证书、以及一个服务器生成的随机数（Server random）。
第三步，爱丽丝确认数字证书有效，然后生成一个新的随机数（Premaster secret），并使用数字证书中的公钥，加密这个随机数，发给鲍勃。
第四步，鲍勃使用自己的私钥，获取爱丽丝发来的随机数（即Premaster secret）。
第五步，爱丽丝和鲍勃根据约定的加密方法，使用前面的三个随机数，生成"对话密钥"（session key），用来加密接下来的整个对话过程。

### 私钥的作用


> **`重点`**
> （1）生成对话密钥一共需要三个随机数。
（2）握手之后的对话使用"对话密钥"加密（对称加密），服务器的公钥和私钥只用于加密和解密"对话密钥"（非对称加密），无其他作用。
（3）服务器公钥放在服务器的数字证书之中。


### DH算法的握手阶段

整个握手阶段都不加密（也没法加密），都是明文的。因此，如果有人窃听通信，他可以知道双方选择的加密方法，以及三个随机数中的两个。整个通话的安全，只取决于第三个随机数（Premaster secret）能不能被破解。

虽然理论上，只要服务器的公钥足够长（比如2048位），那么Premaster secret可以保证不被破解。但是为了足够安全，我们可以考虑把握手阶段的算法从默认的RSA算法，改为 Diffie-Hellman算法（简称DH算法）。

### session的恢复

两种方法可以恢复原来的session：一种叫做session ID，另一种叫做session ticket。


## [大型网站的HTTPS实践一：HTTPS协议和原理](http://www.admin5.com/article/20150505/597061.shtml){:target="_blank"}

> 申请证书
 startssl
 mozilla 发起的免费证书项目：let’s encrypt(https://letsencrypt.org/)
  verisign 公司的证书一般也就几千到几万块一年不等
  如果使用 SPDY，HTTPS 的速度甚至还要比 HTTP 快


### 身份认证

身份认证主要涉及到 **PKI**（公钥基础设施） 和**数字证书**

数字证书有两个作用

> （1） 身份授权。确保浏览器访问的网站是经过 CA 验证的可信任的网站。
> （2）分发公钥。每个数字证书都包含了注册者生成的公钥。在 SSL 握手时会通过 certificate 消息传输给客户端

申请者拿到 CA 的证书并部署在网站服务器端，那浏览器发起握手接收到证书后，如何确认这个证书就是 CA 签发的呢?怎样避免第三方伪造这个证书?

答案就是数字签名(digital signature)。数字签名是证书的防伪标签，目前使用最广泛的 SHA-RSA 数字签名的制作和验证过程如下：

>（1） 数字签名的签发。首先是使用哈希函数对待签名内容进行安全**哈希**，生成消息摘要，然后使用 CA 自己的私钥对消息摘要进行加密。
>（2）数字签名的校验。使用 CA 的公钥解密签名，然后使用相同的签名函数对待签名证书内容进行签名并和服务端数字签名里的签名内容进行比较，如果相同就认为校验成功。
>![Alt text](/images/blog/2017.04.07/digital_identify.png)



----------

### **`补充`** [哈希(Hash)与加密(Encrypt)的基本原理、区别及工程应用](https://www.cnblogs.com/leoo2sk/archive/2010/10/01/hash-and-encrypt.html){:target="_blank"}
1. 哈希（Hash）与加密（Encrypt）的区别
> 哈希（Hash）是将目标文本转换成具有相同长度的、不可逆的杂凑字符串（或叫做消息摘要）
> 而加密（Encrypt）是将目标文本转换成具有不同长度的、可逆的密文。

2. 哈希（Hash）与加密（Encrypt）的数学基础
> 由于哈希算法的定义域是一个无限集合，而值域是一个有限集合，将无限集合映射到有限集合，根据“鸽笼原理(Pigeonhole principle)”，每个哈希结果都存在无数个可能的目标文本，因此哈希不是一一映射，是不可逆的。

 **一个设计良好的哈希算法应该很难从哈希结果找到哈希目标文本的碰撞（Collision）**
> 对于一个哈希算法H，如果S1 ≠ S2 H(S1) = H(S2)，则S1和S2互为碰撞

 **好的哈希算法应该对于输入的改变极其敏感**
> 即使输入有很小的改动，如一亿个字符变了一个字符，那么结果应该截然不同。这就是为什么哈希可以用来检测软件的完整性。

 **一个设计良好的加密算法应该是一个“单向陷门函数(Trapdoor one-way function)”**
>而“陷门”是一个特殊的元素，一旦知道了陷门，则这种逆转换则非常容易进行，具体到加密算法，陷门就是密钥

3. 哈希（Hash）与加密（Encrypt）在软件开发中的应用
>哈希与加密在现代工程领域应用非常广泛，在计算机领域也发挥了很大作用，这里我们仅仅讨论在平常的软件开发中最常见的应用——数据保护。

    基本原则是：**如果被保护数据仅仅用作比较验证，在以后不需要还原成明文形式，则使用哈希；如果被保护数据在以后需要被还原成明文，则需要使用加密。**
> 你以前登录过的很多网站，是不是当你忘记口令的时候，网站并不是将你忘记的口令发送给你，而是发送给你一个新的、随机的口令，然后让你用这个新口令登录。这是因为你在注册时输入的口令被哈希后存储在数据库里，而哈希算法不可逆，所以即使是网站管理员也不可能通过哈希结果复原你的口令，而只能重置口令

 **当前最常用的哈希算法是MD5和SHA1**
> `感慨一下` 搞了半天，原来是你啊（捂脸）
